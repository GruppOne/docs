\documentclass[../../norme-di-progetto.tex]{subfiles}

\begin{document}

\subsubsection{Finalità}%
\label{subs:sviluppo/finalita}

GruppOne istanzia il processo di sviluppo per realizzare il prodotto richiesto dal proponente.

\subsubsection{Descrizione}%
\label{subs:sviluppo/descrizione}

Il processo di sviluppo fissa quali sono gli obiettivi dello sviluppo, dalla creazione alla consegna del prodotto finale.

Raggruppa le seguenti attività:
\begin{itemize}
  \item Analisi dei requisiti
  \item Progettazione
  \item Codifica
  \item Testing
  \item Installazione.
\end{itemize}

\subsubsection{Attività}%
\label{subs:sviluppo/attivita}

\paragraph{Analisi dei requisiti}%
\label{par:analisi_dei_requisiti}
L'analisi dei requisiti è l'attività che studia e comprende il dominio applicativo del problema e ha come scopo quello di offrire i requisiti che dovranno essere soddisfatti dal software.

Si articola nei seguenti compiti:

\begin{itemize}
  \item Delineare i casi d'uso del sistema a partire dal capitolato e dallo \textit{studio di fattibilità}.
  \item Realizzare i diagrammi UML dei casi d'uso.
  \item Determinare i requisiti impliciti ed espliciti del sistema.
  \item Classificare i requisiti.
  \item Ricavare i requisiti atomici da fornire ai progettisti perché possano iniziare l'attività di progettazione.
\end{itemize}

Il documento di riferimento, \textit{Analisi dei requisiti}, è redatto dagli analisti.

\subparagraph{Classificazione dei requisiti}%
\label{subp:classificazione_dei_requisiti}

Per identificare i requisiti in maniera univoca, GruppOne ha deciso di adottare delle norme per la classificazione dei requisiti.
Ogni requisito è caratterizzato da un codice alfanumerico così formato:
\begin{center}
  \textbf{R[numero][tipo][priorità]}
\end{center}
in cui ogni elemento ha un diverso significato:
\begin{description}
  \item [numero] indica quale numero di caso d’uso si sta esaminando. È un numero di tre cifre progressivo a partire da 1, con eventuali 0 di riempimento a partire dalla cifra più significativa.
  \item [tipo] individua la tipologia di requisito. Esso può essere:
        \begin{description}
          \item [F (funzionale)] indica servizi che il sistema dovrebbe fornire.
          \item [P (prestazionale)] indica le prestazioni che il programma deve fornire: velocità in esecuzione e memoria occupata.
          \item [D (dichiarativo)] indica requisiti definiti dall'esterno, ad esempio requisiti di vincolo esposti nel capitolato.
        \end{description}
  \item [priorità] determina la priorità del requisito con un numero da 1 a 3:
        \begin{enumerate}
          \item requisito obbligatorio che deve essere assolutamente soddisfatto dal sistema.
          \item requisito desiderabile il cui soddisfacimento è apprezzato dal committente.
          \item requisito facoltativo la cui decisione è lasciata al team.
        \end{enumerate}
\end{description}

\subparagraph{Casi d'uso}%
\label{subp:casi_d'uso}
I diagrammi dei casi d'uso descrivono le funzioni e i servizi offerti dal prodotto agli attori che interagiscono con il sistema. Ogni caso d'uso ha:

\begin{itemize}
  \item Una rappresentazione testuale
  \item Una rappresentazione grafica.
\end{itemize}

Nel presente paragrafo si descrive la prima mentre nel successivo verrà descritta la seconda.
Un generico caso d'uso è caratterizzato da:
\begin{description}
  \item [Sigla del caso d'uso] per riflettere più chiaramente il sistema che stiamo sviluppando anteponiamo una lettera maiuscola al caso d'uso.
        Useremo:
        \begin{description}
          \item [A] per distinguere i casi d'uso validi nell'interfaccia web.
          \item [U] per distinguere i casi d'uso validi nell'applicazione.
        \end{description}
  \item [Titolo] breve titolo del caso d'uso.
  \item [Codice] codice identificativo del caso d'uso. Ogni caso d'uso può essere suddiviso in altri sottocasi. La denominazione convenzionale è la seguente:
        \begin{description}
          \item [Caso d'uso] [A/U]UC[codice numerico]
          \item [Sottocaso d'uso] [A/U]UC[codice numerico del genitore].[codice numerico del sottocaso].
        \end{description}
        Ad esempio il primo caso d'uso interfaccia web avrà codice identificativo AUC1 mentre i relativi sottocasi saranno AUC1.1 AUC1.2 AUC1.3..
  \item [Attore primario] attore principale coinvolto nel caso d'uso.
  \item [Attori secondari (opzionale)] attori secondari coinvolti nel caso d'uso.
  \item [Precondizione] condizione in cui si trovano gli attori prima del verificarsi del caso d'uso.
  \item [Postcondizione] condizione in cui si trovano gli attori dopo il verificarsi del caso d'uso.
  \item [Scenario principale] sequenza di azioni svolte dall'attore per portare a compimento il caso d'uso.
  \item [Inclusioni (opzionale)] il caso d'uso incluso è incondizionatamente eseguito dal caso d'uso che lo include.
  \item [Estensioni (opzionale)] sequenza di possibilità dell'attore al verificarsi di eventi anomali o di situazioni di errore.
\end{description}

\subparagraph{Diagrammi UML dei casi d'uso}%
\label{subp:diagrammi_UML_dei_casi_d'uso}
I diagrammi dei casi d'uso forniscono una rappresentazione grafica del caso d'uso che si sta descrivendo. I principali elementi di un diagramma UML sono:
\begin{itemize}
  \item Attori
  \item Scenario
  \item Use case.
\end{itemize}
Gli attori che interagiscono con il sistema si trovano fuori dallo scenario, mentre gli use case sono parte integrante dello scenario.
I collegamenti tra attori e casi d'uso, e tra quest'ultimi e altri casi d'uso, avvengono tramite legami rappresentati mediante linee.
Possono essere di quattro differenti tipi:
\begin{description}
  \item [Associazione] l'associazione è la comunicazione diretta tra attore e use case. Rappresenta la partecipazione dell'attore al caso d'uso a cui è legato.
  \item [Inclusione] L'inclusione è un legame diretto stretto tra due use case. Dati due casi d'uso A e B, si dice che A include B se ogni istanza di A esegue B. B è incluso nell'esecuzione di A e la responsabilità di esecuzione di B è unicamente di A.
  \item [Estensione] L'estensione aumenta le funzionalità di uno use case. Dati due casi d'uso A e B, si dice che B estende A se A esegue B solo a determinate condizioni. L'esecuzione di B interrompe A e per questo motivo viene utilizzata prevalentemente per gestire errori e eccezioni.
  \item [Generalizzazione] La generalizzazione è un legame tra attori o più raramente tra use case. Dati due casi d'uso A e B, A è generalizzazione di B se condivide almeno le funzionalità di A. B può modificare le funzionalità di A, mentre tutte le funzionalità non ridefinite si mantengono identiche a quelle di A.
\end{description}

\paragraph{Progettazione}%
\label{par:progettazione}
L'attività di progettazione precede la codifica e si occupa di organizzare le componenti del sistema cercando una soluzione che possa soddisfare tutti gli stakeholders e che adempia alle necessità e hai bisogni definiti nell'\textit{Analisi dei requisiti}.

Essa procede inversamente rispetto a quest`ultima la quale adotta un approccio investigativo, di studio del dominio applicativo e di scomposizione dei requisiti.
La progettazione cerca, invece, di fissare l'\glossario{architettura} del prodotto adottando un approccio di tipo sistematico.

Essa si pone i seguenti obiettivi:
\begin{itemize}
  \item Definire l'architettura logica del prodotto trattando il sistema come un insieme di parti.
  \item Soddisfare i requisiti con un sistema di qualità.
  \item Ricercare una buona soluzione architetturale perseguendo la correttezza per costruzione piuttosto che la correttezza per correzione.
  \item Utilizzare best practices per proporre soluzioni architetturali eleganti, efficaci ed efficienti che facilitino l'attività di codifica.
\end{itemize}
La progettazione si divide in due periodi separati:
\begin{itemize}
  \item Nel primo periodo si effettua la progettazione architetturale che verrà esposta in un documento denominato \textit{Technology baseline}.
  \item Nel secondo periodo si effettua la progettazione in dettaglio e la codifica che sono oggetto della \textit{Product baseline}.
\end{itemize}

\subparagraph{Technology Baseline}%
\label{subp:technology_baseline}
La \glossario{Technology Baseline} è un documento tecnico parte integrante della revisione di progettazione. Essa presenta:

\begin{itemize}
  \item Le tecnologie
  \item I framework
  \item Le librerie.
\end{itemize}
Deve contenere inoltre una \glossario{Proof of Concept}, un eseguibile che ha lo scopo di evidenziare come le tecnologie utilizzate possano servire allo sviluppo del prodotto.

\subparagraph{Product Baseline}%
\label{subp:product_baseline}
La \glossario{Product Baseline} è un documento tecnico parte integrante della revisione di qualifica.
Ha il compito di mostrare l'architettura del prodotto attraverso la creazione di diagrammi ``a grana fine'' (e.g.\ diagrammi delle classi o di package) e l'uso di \glossario{Design pattern}.

\subparagraph{Qualità di una buona architettura}%
\label{subp:qualita_di_una_buona_architettura}

Durante il periodo di progettazione architetturale i progettisti effettuano una progettazione ``ad alto livello'' e si impegnano ad individuare le principali componenti del sistema e a definirne le relazioni. Il prodotto della progettazione architetturale è un modello che descrive come le parti interagiscano tra di loro. Nel periodo di progettazione in dettaglio, invece, si definiscono con maggiore precisione le singole unità del sistema che devono essere coese, rapide e verificabili in modo da agevolare i programmatori nella codifica. Essendo l'architettura a garantire l'organizzazione e la coesione dei componenti si intuisce come rivesta un ruolo fondamentale per ottenere un prodotto di qualità. A tal proposito essa dovrà avere le seguenti caratteristiche:
\begin{description}
  \item [Sufficienza]: deve soddisfare tutti i requisiti definiti nel documento di \textit{Analisi dei requisiti}.
  \item [Comprensibilità]: deve essere comprensibile a tutti gli stakeholders.
  \item [Modularità]: deve essere suddivisa in parti chiare e distinte minimizzando le dipendenze.
  \item [Robustezza]: deve saper tollerare carichi di lavoro in ingresso variabili.
  \item [Flessibilità]: al variare dei requisiti deve essere possibile apportare modifiche senza problemi.
  \item [Riusabilità]: le sue parti possono essere reimpiegabili.
  \item [Efficienza]: deve fare uso di un adeguato numero di risorse.
  \item [Affidabilità]: deve svolgere il compito per il quale è stata realizzata.
  \item [Disponibilità]: deve essere disponibile.
  \item [Sicurezza rispetto a malfunzionamenti]: non deve avere malfunzionamenti gravi.
  \item [Sicurezza rispetto a intrusioni]: deve tutelare ogni forma di dato sensibile e non deve essere vulnerabile.
  \item [Semplicità]: deve contenere tutto il necessario e nulla di superfluo.
  \item [Incapsulazione]: le componenti non devono essere visibili all'esterno.
  \item [Coesione]: le parti devono condividere i medesimi obiettivi.
  \item [Basso accoppiamento]: deve minimizzare le dipendenze.
\end{description}

\subparagraph{Diagrammi UML}%
\label{subp:diagrammi_UML}
Per illustrare le proprie scelte progettuali GruppOne realizzerà dei diagrammi mediante il linguaggio visivo \glossario{UML 2.0}.
Tali diagrammi includono:
\begin{itemize}
  \item Diagrammi delle classi: presentano i metodi, gli attributi e le relazioni di ciascun oggetto con il sistema.
  \item Diagrammi di package: illustrano come sono raggruppate le classi che condividono elementi comuni mediante un'unità di livello più alto.
  \item Diagrammi di attività: descrivono la logica procedurale dei casi d'uso e ne mostrano gli aspetti dinamici.
  \item Diagrammi di sequenza: definiscono come gli oggetti collaborano tra di loro per riprodurre un comportamento comune.
\end{itemize}
Nei prossimi paragrafi verranno presentate le norme a cui i progettisti dovranno attenersi nella produzione dei diagrammi.
\subparagraph{Diagrammi delle classi}%
\label{subp:diagrammi_delle_classi}
Una classe, in UML, ha la sottostante rappresentazione:
\begin{minted}{text}
  @startuml
  skinparam classAttributeIconSize 0
  class dummy {
    {static}-field1
    #field2

    ~method1()
    +method2()
  }
@enduml
\end{minted}

\begin{description}
  \item [Nomi e visibilità]: i nomi di classi, campi dati e metodi andranno indicati in minuscolo e scritti in lingua inglese. Inoltre, come in un vero e proprio linguaggio di programmazione in UML è possibile indicare la visibilità di una variabile o di un metodo:
        \begin{description}
          \item [-]: visibilità privata
          \item [\#]: visibilità protetta
          \item [+]: visibilità pubblica
          \item [\textasciitilde]: visibilità a livello di package
        \end{description}
  \item[Altre convenzioni]:
        \begin{itemize}
          \item I campi dati e i metodi statici devono essere sottolineati.
          \item Utilizzare \textit{{abstract}} per indicare classi astratte.
          \item Fare uso di \textit{<<interface>>} per indicare interfacce.
          \item Il tipo delle variabili e il tipo di ritorno va posto dopo il nome della variabile o del metodo in questione. Ad esempio:
                \begin{center}
                  \textit{-field1: String} \\\textit{+method1: int}
                \end{center}
        \end{itemize}
\end{description}
\subsubsection{Strumenti}%
\label{subs:strumenti}

\paragraph{PlantUML}%
\label{par:plantuml}
Per la costruzione dei diagrammi UML il team ha deciso di utilizzare \glossario{PlantUML}\@.
È un software open source che permette la costruzione di diagrammi UML a partire dalla scrittura di codice in un linguaggio di markup dedicato. GruppOne ha valutato positivamente tale strumento in quanto:

\begin{itemize}
  \item Gli aspetti grafici di costruzione dei diagrammi sono demandati al software sottostante.
  \item La sua natura testuale e dichiarativa permette di attuare un versionamento efficace dei diagrammi attraverso strumenti che già utilizziamo.
  \item Permette di scrivere agevolmente i diagrammi dei casi d'uso, delle classi, di sequenza e di package.
\end{itemize}

In seguito a difficoltà nell'utilizzo del package apposito di \LaTeX{}, abbiamo deciso di pre-compilare separatamente i diagrammi utilizzando le funzionalità esposte dalla \glossario{Command Line Interface} di PlantUML\@.

Posizionarsi nella cartella contenente la documentazione di progetto ed eseguire il comando:

\begin{minted}{bash}
  java \
    -jar \
    $PLANTUML_JAR \
    -checkmetadata \
    -charset UTF-8 \
    -x **/commons/style/*.pu \
    -o img \
    **/**.pu
\end{minted}

La corretta esecuzione del comando richiede di aver impostato la variabile d'ambiente \verb|PLANTUML_JAR| al percorso completo del file \verb|plantuml.jar| reperito dal sito del progetto.

In questo modo vengono generate le immagini che sono effettivamente incluse nei documenti dal comando dato in~\ref{par:LaTeX}.

\subparagraph{Esempio diagramma PlantUML}%
\label{subp:esempio_diagramma_plantuml}

\begin{minted}{text}
  @startuml
  left to right direction
  skinparam packageStyle rectangle
  actor customer
  actor clerk
  rectangle checkout {
    customer -- (checkout)
    (checkout) .> (payment) : include
    (help) .> (checkout) : extends
    (checkout) -- clerk
  }
  @enduml
\end{minted}

Il risultato grafico del codice è presentato in~\ref{fig:esempio_caso_duso}

\begin{figure}[H]%
  \label{fig:esempio_caso_duso}
  \includegraphics[width=8cm]{use-case-example.png}
  \centering
  \caption{diagramma dei casi d'uso realizzato con PlantUML}
\end{figure}

% subp:esempio_diagramma_plantuml (end)

\paragraph{Package pgfgantt}%
\label{par:pgfgantt}

Per i diagrammi di Gantt il gruppo ha scelto di utilizzare pgfgantt, un package disponibile per \LaTeX{} che sfrutta il linguaggio \glossario{PGF} e il rispettivo omonimo interprete.
PGF è in grado di produrre rappresentazioni grafiche vettoriali, e pgfgantt fornisce dei comandi \TeX{} che fungono da astrazioni per le direttive di basso livello.
Un diagramma di Gantt viene quindi costruito attraverso uno o più comandi di titolo, seguiti da una combinazione di comandi specifici per inserire gruppi, ``barre'' (cioè attività) o milestone, oppure per collegare due elementi.

L'integrazione dei diagrammi nel documento avviene durante la compilazione del documento effettuata attraverso il comando dato in~\ref{par:LaTeX}.

% par:pgfgantt (end)

\subsubsection{Metriche di processo}%
\label{subs:sviluppo/metriche_di_processo}

\paragraph{MPS-ROS: Requisiti obbligatori soddisfatti}% in questo caso NON ci va il "\@". chktex 13
\label{par:MPS-ROS_requisiti_obbligatori_soddisfatti}

La metrica requisiti obbligatori soddisfatti indica la percentuale di requisiti obbligatori soddisfatti sul numero totale di requisiti obbligatori. La formula è la seguente:
\[
  \frac{requisiti\ obbligatori\ soddisfatti}{requisiti\ obbligatori\ totali}\cdot 100
\]
% TODO scrivi metriche di codifica (grosso)
% TODO basta scrivere statement/branch/decision coverage per ora?
% Per il momento le lasciamo perdere le rimandiamo alla progettazione architetturale

\end{document}
