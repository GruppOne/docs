\documentclass[../manuale-manutentore.tex]{subfiles}

\begin{document}

Di seguito vengono descritti i comandi da eseguire nella CLI per il test di ogni componente del sistema di Stalker.

% \subsection{Server}%
% \label{sub:}
%TODO

\subsection{Web application}%
\label{sub:}

\subsubsection{Esecuzione test di unità}%
\label{subs:esecuzione_test_di_unita}

Per eseguire i test di unità tramite Karma, eseguire il comando: \par\bigskip

\begin{center}
  \textit{ng test}
\end{center}
\par\bigskip

\subsubsection{Estensione test di unità}%
\label{subs:estensione_test_unita_webapp}

I test di unità vengono definiti utilizzando la sintassi di Jasmine, dunque per aggiungerne uno ad un componente è sufficiente creare un blocco come il seguente:

\typescript{  it('should create', () => { %chktex 36
  expect(component).toBeTruthy(); %chktex 36
});} %chktex 36
\newline
Poi definire un altro test.
I test in seguito verranno eseguiti con il framework Karma, che li esegue sul browser Chrome.

% subs:estensione_test_unita_webapp (end)
\subsubsection{Esecuzione test end-to-end}%
\label{subs:esecuzione_test_end_to_end}

Per eseguire i test end-to-end tramite Protractor, eseguire il comando: \par\bigskip

\begin{center}
  \textit{ng e2e}
\end{center}
\par\bigskip

\subsubsection{Estensione test end-to-end}%
\label{subs:estensione_test_end_to_end}
I test end-to-end vengono definiti utilizzando la sintassi gherkin all'interno del framework cucumber, quindi la prima cosa da fare è definire testualmente il test.
In seguito vanno definiti gli step in codice a cui gli step testuali corrispondono.
Infine i test vanno eseguiti tramite Protractor, che simula l'interazione dell'utente con il browser.
% subs:estensione_test_end_to_end (end)

% \subsection{Mobile application}%
% \label{sub:}
%TODO
\subsection{Server}%
\label{sub:Server}

\subsubsection{Test di unità e test end to end}%

I test sono eseguiti mediante il framework Junit 5. Per eseguire i test è necessario compilare il progetto con il seguente comando:
 \begin{minted} {bash}
    ./gradlew build
 \end{minted}

Il wrapper di gradle si occuperà di eseguire la build e successivamente tutti i test presenti nella cartella \textit{test} del progetto.
Nel caso in cui al più un test fallisse, la build dell'intero progetto non andrà a buon fine.
Se si volesse compilare il progetto senza eseguire i test si utilizzi il comando:
\begin{minted} {bash}
   ./gradlew build -x test
\end{minted}
Per misurare la coverage del codice abbiamo utilizzato il tool di Java denominato Jacoco.
Esso permette di misurare quattro tipi di coperture:
\begin{itemize}
  \item La copertura totale per ogni blocco di codice.
  \item La copertura totale del codice di tutto il progetto.
  \item La copertura totale all'interno di un branch (ad esempio nelle istruzioni condizionali).
  \item La copertura totale all'interno di un metodo.
\end{itemize}
Ad ogni compilazione del codice, a partire dalla root del progetto e seguendo il path \textit{build/reports/tests/test}
è possibile trovare un file index.html che se aperto sul browser permette di visualizzare un report che mostra quante e quali
linee di codice sono in totale coperte dai test.

% sub:Server (end)


\end{document}
